# About D3D and OpenGL Major matrix

D3D 使用的矩陣運算是 row matrix
			
    [x y z w] * Matrix[4x4]

OpenGL 使用的矩陣運算是 column matrix

    			  [ x ]
    Matrix[4x4] * [ y ]
    			  [ z ]
    			  [ w ]

參考資料

- [關於 OpenGL 和 D3D 的 major matrix](http://blog.cxxl3d.tk/2013/05/opengl-d3d-major-matrix.html?showComment=1444214449193#c7421675933099775191)
- [Matrix Layouts, DirectX and OpenGL](http://www.mindcontrol.org/~hplus/graphics/matrix-layout.html)


看到這裡會覺得 有什麼差別?

疑問1: [ x y z w ] 組成一個向量點，當一個點的時候，w =1 ，如果是方向 w = 0 。

疑問2: 這導致 許多運算用的矩陣放置的位置不一樣!! 

比方說使用 OpenGL ，由於Vector是最後乘上去的 ，越靠近向量點的運算會先處理。

像典型的乘法順序必須依照  scale, rotation 最後 translation。
但是程式碼必須寫成

    glRotatef(90, 0, 1, 0); // Notice how this is the first operation ...
    // ... but will be applied after
    glScalef(1, 10, 1); // This will be applied first, but is the last operation
    // Zany, right?

另外轉置矩陣可用於 D3D 跟 OpenGL 的執行順序

參考資料
[Opengl order of matrix transformations](http://stackoverflow.com/questions/15993339/opengl-order-of-matrix-transformations/15995026#15995026)


D3D 使用 row-major 的方式儲存矩陣,配合 row matrix 矩陣運算
    
    			[ m0  m1  m2  m3  ]
    [x y z w] * [ m4  m5  m6  m7  ]  = [x' y' z' w']
    			[ m8  m9  m10 m11 ]
    			[ m12 m13 m14 m15 ]
    
    x' = x*m0 + y*m4 + z*m8  + w*m12
    y' = x*m1 + y*m5 + z*m9  + w*m13
    z' = x*m2 + y*m6 + z*m10 + w*m14
    w' = x*m3 + y*m7 + z*m11 + w*m15
    
OpenGL 使用 column-major 的方式儲存矩陣,配合 column matrix 矩陣運算
    
    [ m0  m4  m8  m12 ]	  [ x ]   [ x']
    [ m1  m5  m9  m13 ] * [ y ] = [ y']
    [ m2  m6  m10 m14 ]	  [ z ]   [ z']
    [ m3  m7  m11 m15 ]	  [ w ]   [ w']
    
    x' = x*m0 + y*m4 + z*m8  + w*m12
    y' = x*m1 + y*m5 + z*m9  + w*m13
    z' = x*m2 + y*m6 + z*m10 + w*m14
    w' = x*m3 + y*m7 + z*m11 + w*m15
    
**仔細看運算方式是一模一樣!!**

**但差別在哪裡呢? 矩陣「看」起來會有所不同，但是運算都一樣! **

參考資料

- [OpenGL基本矩陣運算](http://www3.ntu.edu.sg/home/ehchua/programming/opengl/cg_basicstheory.html)
- [D3D基本矩陣運算](https://msdn.microsoft.com/zh-tw/library/windows/desktop/bb206269%28v=vs.85%29.aspx)

----------

# 矩陣運算 #

c = cos 

s = sin 

|vertor[x y z]| = vertor's length.

normalize will make vector length equals 1.

cross = cross product

    cross(left, right)
    L = left, R = right

    left x right =   |  X  Y  Z |
                     | Lx Ly Lz |
                     | Rx Ry Rz |
                 
                 =   | Ly Lz |    | Lz Lx |    | Lx Ly |
                     | Ry Rz |X + | Rz Rx |Y + | Rx Ry |Z
    
                 =   (Ly*Rz - Ry*Lz)X + (Lz*Rx - Rz*Lx)Y + (Lx*Ry - Rx*Ly)Z 
    
	Vector.x = Ly*Rz - Ry*Lz
	Vector.y = Lz*Rx - Rz*Lx
	Vector.z = Lx*Ry - Rx*Ly

	cross(left, right) = -cross(right, left)


dot = dot product

	dot(left, right)

    L = left, R = right

	result = Lx*Rx + Ly*Ry + Lz*Rz


##D3D##

###D3D Scale

				[ Sx  0  0 0 ]
	[x y z w] * [  0 Sy  0 0 ]
				[  0  0 Sz 0 ]
				[  0  0  0 1 ] 

----------
###D3D Rotation X-axis

    			[ 1  0  0 0 ]
    [x y z w] * [ 0  c  s 0 ]
    			[ 0 -s  c 0 ]
    			[ 0  0  0 1 ]

----------
###D3D Rotation Y-axis

    			[ c  0 -s 0 ]
    [x y z w] * [ 0  1  0 0 ]
    			[ s  0  c 0 ]
    			[ 0  0  0 1 ]

----------

###D3D Rotation Z-axis

    			[ c  s  0 0 ]
    [x y z w] * [-s  c  0 0 ]
    			[ 0  0  1 0 ]
    			[ 0  0  0 1 ]

----------

###D3D Translation Matrix
    
                [ 1	 0  0 0]
    [x y z w] * [ 0	 1  0 0]
                [ 0	 0  1 0]
                [Tx Ty Tz 1]

----------

###D3D LookAtLH Matrix ( Left-handed ) *
[D3DXMatrixLookAtLH function](https://msdn.microsoft.com/en-us/library/windows/desktop/bb205342%28v=vs.85%29.aspx)

左手中指Z+指向出去，因此自己的眼睛(eye)為負值，因此 Zaxis = normalize(target - eye)。 

拇指指向+Z，四指呈現逆時鐘方向。

Up x Zaxis = Xaxis

Zaxis x  Xaxis = Yaxis
    
    Define: Up = normalize( Up[x y z] )
    
    Zaxis = normalize(target[x y z] - eye[x y z])
    Xaxis = normalize(cross(Up, Zaxis))
    Yaxis = normalize(cross(Zaxis, Xaxis))
    
    [      1      0      0  0 ]   [ Xaxis.x  Yaxis.x  Zaxis.x  0 ]
    [      0      1      0  0 ] * [ Xaxis.y  Yaxis.y  Zaxis.y  0 ]
    [      0      0      1  0 ]   [ Xaxis.z  Yaxis.z  Zaxis.z  0 ]
    [ -eye.x -eye.y -eye.z  1 ]   [       0        0        0  1 ]

      [         Xaxis.x          Yaxis.x         Zaxis.x  0 ]
    = [         Xaxis.y          Yaxis.y         Zaxis.y  0 ]
      [         Xaxis.z          Yaxis.z         Zaxis.z  0 ]
      [ -dot(Xaxis,eye)  -dot(Yaxis,eye) -dot(Zaxis,eye)  1 ]

----------

###D3D LookAtRH Matrix ( Right-handed )
[D3DXMatrixLookAtRH function](https://msdn.microsoft.com/en-us/library/windows/desktop/bb205343%28v=vs.85%29.aspx)

右手中指Z+指向自己的眼睛，因此自己的眼睛(eye)為正值，因此 Zaxis = normalize(eye-target)。 

拇指指向+Z，四指呈現逆時鐘方向。

Up x Zaxis = Xaxis

Zaxis x  Xaxis = Yaxis

    Define: Up = normalize( Up[x y z] )
    
    Zaxis = normalize(eye[x y z] - target[x y z])
    Xaxis = normalize(cross(Up, Zaxis))
    Yaxis = normalize(cross(Zaxis, Xaxis))
    
    [      1      0      0  0 ]   [ Xaxis.x  Yaxis.x  Zaxis.x  0 ]
    [      0      1      0  0 ] * [ Xaxis.y  Yaxis.y  Zaxis.y  0 ]
    [      0      0      1  0 ]   [ Xaxis.z  Yaxis.z  Zaxis.z  0 ]
    [  eye.x  eye.y  eye.z  1 ]   [       0        0        0  1 ]

      [         Xaxis.x          Yaxis.x         Zaxis.x  0 ]
    = [         Xaxis.y          Yaxis.y         Zaxis.y  0 ]
      [         Xaxis.z          Yaxis.z         Zaxis.z  0 ]
      [  dot(Xaxis,eye)   dot(Yaxis,eye)   dot(Zaxis,eye)  1 ]

----------

##OpenGL

###OpenGL Scale

	[ Sx  0  0 0 ]   [ x ]
	[  0 Sy  0 0 ] * [ y ]
	[  0  0 Sz 0 ]   [ z ]
	[  0  0  0 1 ]   [ w ]

----------

###OpenGL Rotation X-axis

    [ 1  0  0 0 ]	[ x ]
    [ 0  c -s 0 ] * [ y ]
    [ 0  s  c 0 ]	[ z ]
    [ 0  0  0 1 ]	[ w ]

----------

###OpenGL Rotation Y-axis

    [ c  0  s 0 ]	[ x ]
    [ 0  1  0 0 ] * [ y ]
    [-s  0  c 0 ]	[ z ]
    [ 0  0  0 1 ]	[ w ]

----------

###OpenGL Rotation Z-axis

    [ c -s  0 0 ]	[ x ]
    [ s  c  0 0 ] *	[ y ]
    [ 0  0  1 0 ]	[ z ]
    [ 0  0  0 1 ]	[ w ]

----------

###OpenGL Translation Matrix
    
    [ 1	0 0 Tx ]   [ x ]
    [ 0	1 0 Ty ] * [ y ]
    [ 0	0 1 Tz ]   [ z ]
    [ 0 0 0 1  ]   [ w ]

----------

###OpenGL LookAtLH Matrix ( Left-handed )
**# OpenGL 不提供 Left-handed**

左手中指Z+指向出去，因此自己的眼睛(eye)為負值，因此 Zaxis = normalize(target - eye)。 

拇指指向+Z，四指呈現逆時鐘方向。

Up x Zaxis = Xaxis

Zaxis x  Xaxis = Yaxis

    Define: Up = normalize( Up[x y z] )
    
    Zaxis = normalize(target[x y z] - eye[x y z])
    Xaxis = normalize(cross(Up, Zaxis))
    Yaxis = normalize(cross(Zaxis, Xaxis))

    [ Xaxis.x  Xaxis.y  Xaxis.z  0 ]   [      1       0       0   -eye.x ]
    [ Yaxis.x  Yaxis.y  Yaxis.z  0 ] * [      0       1       0   -eye.y ]
    [ Zaxis.x  Zaxis.y  Zaxis.z  0 ]   [      0       0       1   -eye.z ]
    [       0        0        0  1 ]   [      0       0       0        1 ]

      [  Xaxis.x  Xaxis.y  Xaxis.z  -dot(Xaxis, eye) ]
    = [  Yaxis.x  Yaxis.y  Yaxis.z  -dot(Yaxis, eye) ]
      [  Zaxis.x  Zaxis.y  Zaxis.z  -dot(Zaxis, eye) ]
      [        0        0        0                 1 ]

----------

###OpenGL LookAtRH Matrix ( Right-handed ) *
[gluLookAt](http://people.freedesktop.org/~idr/glu3/glu3_8h.html)

右手中指Z+指向自己的眼睛，因此自己的眼睛(eye)為正值，因此 Zaxis = normalize(eye-target)。 

拇指指向+Z，四指呈現逆時鐘方向。

Up x Zaxis = Xaxis

Zaxis x  Xaxis = Yaxis

    Define: Up = normalize( Up[x y z] )
    
    Zaxis = normalize(eye[x y z]- target[x y z])
    Xaxis = normalize(cross(Up, Zaxis))
    Yaxis = normalize(cross(Zaxis, Xaxis))

    [ Xaxis.x  Xaxis.y  Xaxis.z  0 ]   [      1       0       0    eye.x ]
    [ Yaxis.x  Yaxis.y  Yaxis.z  0 ] * [      0       1       0    eye.y ]
    [ Zaxis.x  Zaxis.y  Zaxis.z  0 ]   [      0       0       1    eye.z ]
    [       0        0        0  1 ]   [      0       0       0        1 ]

      [  Xaxis.x  Xaxis.y  Xaxis.z  dot( Xaxis, eye) ]
    = [  Yaxis.x  Yaxis.y  Yaxis.z  dot( Yaxis, eye) ]
      [  Zaxis.x  Zaxis.y  Zaxis.z  dot( Zaxis, eye) ]
      [        0        0        0                 1 ]

----------

**但是如果寫成程式碼，你會發現根本一模一樣的運算!! 只是D3D使用Left-handed, OpenGL使用Right-handed的差別**

# Transformation

    Object Space
    
    	Model Matrix ( multiply Object's  scale, rotation, translation )
    
    World Space (Model Space)
    
    	View Matrix ( multiply Camera LookAt )
    
    Camera Space (Eye Space or View Space)
    
    	Projection Matrix ( multiply Frustum.  ex: Perspective, Ortho)
    
    Screen Space (Clip Space)

[Coordinate Systems in OpenGL](http://www.matrix44.net/cms/notes/opengl-3d-graphics/coordinate-systems-in-opengl)





Scale * Rotation * Translation

http://gamedev.stackexchange.com/questions/16719/what-is-the-correct-order-to-multiply-scale-rotation-and-translation-matrices-f

Raw
http://www.codinglabs.net/article_world_view_projection_matrix.aspx

